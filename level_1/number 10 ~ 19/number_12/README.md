## (lv.1) 12번 : 과일장수

사과를 포장하는데 이 사과는 상태에 따라 1점부터 `k`점까지의 점수로 분류한다. `k`점이 최상품이며 1점이 최하품이다. 사과 한 상자의 가격은 다음과 같이 결정된다.

- 한 상자에 사과를 `m`개씩 담아 포장한다.
- 상자에 담긴 사과 중 가장 낮은 점수가 `p (1 <= p <= k)`인 경우 사과 한 상자의 가격은 `p * m` 이다.
  가능한 많은 사과를 팔았을 때 최대로 이익이 나게끔 사과를 배분하려고 한다.(사과는 상자단위로만 판매하며 남는 사과는 버린다.)

사과의 최대점수 `k`, 한 상자에 들어가는 사과의 수 `m`, 사과들의 점수 `score`가 주어질 때 최대 이익을 return하는 solution을 작성하라.

---

- 3 <= `k` <= 9

- 3 <= `m` <= 10

- 7 <= `score`의 길이 <= 1,000,000

  - 1 <= `score[i] <= k

- 이익이 발생하지 않는 경우 0을 return

---

점수가 높은 사과들끼리 담는것이 이득이므로 `score`를 `내림차순` 정렬하여 `m`만큼 자르고 분리된 배열의 원소 중 최소값을 구해 가격을 계산한다.

- `sort()`의 callback 인자에 `(a, b) => { return b - a }`를 전달하면 내림차순으로 정렬된다.

- 로직을 더 이상 사과를 담을 수 없을때 까지 `while`문으로 반복한다.

- `slice()` 메소드를 이용하며 원본인 `score` 배열을 변형시키지 않기 위해 `storedBox`에 자른 배열을 선언해준다.

  - 원본이 변하지 않으므로 현재 사과의 index를 대표하는 `target`을 선언한다.
  - `target`은 매 반복시마다 `m`만큼 증가시킨다. 사과상자에는 `m`만큼 사과가 들어가기 때문에 한번 사과를 담으면 `m`만큼 index가 이동하기 때문이다.

- 제대로 사과를 담았다면 분리된 배열을 순회하며 `Math.min()` 메소드를 활용해 점수의 최소값을 구한다.
  - 만약 최소값이 `k`보다 클 경우 최소값을 `k`로 초기화한다.
