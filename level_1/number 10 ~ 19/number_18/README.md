## (lv.1) 18번 : 체육복

학생들의 체육복이 도둑맞았다. 때문에 여벌의 체육복이 있는 학생이 피해 학생들에게 체육복을 빌려주려 한다. 학생들의 번호는 체격 순으로 매겨져 있어, 바로 앞번호 혹은 바로 뒷번호의 학생에게만 체육복을 빌려줄 수 있다.

전체 학생의 수 `n`, 피해 학생들의 번호가 담긴 배열 `lost`, 여벌의 체육복을 가져온 학생들의 번호가 담긴 배열 `reserve`가 주어질 때, 체육복을 지참할 수 있는 최대 학생의 수를 return하는 solution을 작성하라.

---

- 2 <= `n` <= 30
- 1 <= `reserve`, `lost`의 길이 <= n
  - 두 배열 모두 각각의 배열 내에서 중복되는 번호는 없다.
- 여벌의 체육복이 있는 학생만 체육복을 빌려줄 수 있다.
- 여벌의 체육복을 가져온 학생이 동시에 피해학생인 경우가 존재한다. 이 경우에는 해당 학생은 여벌의 체육복을 도난당했다고 가정하여 남은 체육복이 본인의 몫 하나이기 때문에 다른 학생에게 체육복을 빌려줄 수 없다.

---

`filter()`메소드를 이용해 여벌의 체육복을 가져온 학생이 동시에 피해학생인 경우를 먼저 처리한 후 로직을 수행한다.

- 우선 `filter()` 메소드를 이용해 다음과 같은 과정을 수행한다.
  - `lost`의 원소 중 `reserve.includes()`가 `true`인 원소를 제외한 배열 `target`을 선언한다.
  - `reserve`의 원소 중 `lost.includes()`가 `ture`인 원소를 제외한 배열 `cloth`를 선언한다.
  - 두 배열 모두 오름차순으로 정렬한다. 프로그래머스의 테스트 케이스 중 오름차순으로 정렬되지 않은 상태로 매개변수가 주어지는 경우가 있기 때문
- 체육복을 지참하지 못하는 학생의 수를 나타내는 변수 `count`의 값을 `target.length`인 채로 선언한다.
- `cloth`와 `target`을 이중 for문으로 순회하며 다음 로직을 수행한다.
  - `target`의 원소가 `cloth의 원소 + 1` 혹은 `cloth의 원소 - 1`과 같을 경우 `count`를 1 감소시키고 `target`에서 해당 조건에 부합하는 원소를 `splice()` 메소드를 이용해 제거한다.
- 최종적으로 전체 학생의 수 `n`에서 `count`를 뺀 값을 return한다.
